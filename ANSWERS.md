# Ответы на теоретические вопросы (Задания А1, B2, B3)

## Задание А1: Docker (Вопрос для размышления)

**Вопрос:** Как можно доставить твой index.html в контейнер, не пересобирая образ?

**Ответ:**
Для этого используется механизм **Docker Volumes (тома)**. Мы можем "пробросить" (подмонтировать) файл или директорию с хост-машины внутрь контейнера.
При старте контейнера (через `docker run` или `docker-compose`) нужно указать маппинг.

В `docker-compose.yml` это выглядит так:
```yaml
services:
  web:
    volumes:
       - ./index.html:/usr/share/nginx/html/index.html
```
Теперь при изменении `index.html` на компьютере изменения мгновенно отобразятся в браузере (после обновления страницы), так как Nginx в контейнере читает этот же файл.

---

## Задание B2: Маленькая проблема в Git

**Ситуация 1:** Нужно срочно переключиться на `main`, но есть незакоммиченные изменения.
**Решение:** Используем `git stash` (тайник).

Последовательность команд:
1.  `git stash` - прячем текущие изменения в stash. Рабочая директория становится чистой.
2.  `git checkout main` - спокойно переключаемся на main.
3.  [Делаем исправление бага, коммитим...]
4.  `git checkout feature/junior-task` - возвращаемся в свою ветку.
5.  `git stash pop` - достаем изменения обратно из тайника.

**Ситуация 2:** Нужно переименовать последний коммит.
**Решение:**
1.  Убеждаемся, что мы на нужном коммите и не пушили его (или готовы к force push).
2.  Выполняем: `git commit --amend -m "Новое правильное название коммита"`

---

## Задание B3: Объясни концепцию (CI/CD)

**Задача:** Описать пайплайн автоматической сборки Docker-образа при пуше в `main`.

### Схема процесса (Pipeline)

1.  **Триггер (Push in main)**
    *   Разработчик делает `git push origin main`.
    *   GitLab/GitHub обнаруживает событие и запускает Runner.

2.  **Этап: Checkout (Получение кода)**
    *   CI сервер клонирует репозиторий с кодом.

3.  **Этап: Test (Тестирование)**
    *   Запускаются линтеры (проверка стиля кода).
    *   Запускаются unit-тесты.
    *   *Если тесты падают -> Пайплайн останавливается, отправляется уведомление об ошибке.*

4.  **Этап: Build (Сборка)**
    *   Выполняется команда `docker build -t my-app:latest .`.
    *   Также желательно тегировать версией коммита (SHA), например `my-app:a1b2c3d`.

5.  **Этап: Push (Публикация)**
    *   CI сервер логинится в Docker Hub (`docker login`).
    *   Загружает образ: `docker push my-user/my-app:latest`.

6.  **Этап: Notify (Уведомление)**
    *   Отправляется HTTP-запрос в Telegram Bot API.
    *   Сообщение: "✅ Сборка успешно завершена для ветки main".
    *   *В случае ошибки на любом этапе отправляется сообщение "❌ Сборка упала".*

### Текстовое описание для Telegram (пример шага в .gitlab-ci.yml):
```yaml
notify_success:
  stage: notify
  script:
    - curl -s -X POST https://api.telegram.org/bot<TOKEN>/sendMessage -d chat_id=<CHAT_ID> -d text="✅ Deploy Success"
```
